Простой HTTP-сервис на Go, который позволяет получать пару токенов access + refresh.

Для разработки использовались следующие технологии: Go, библиотека net/http, pgsql, docker, swagger.

ФУНКЦИОНАЛ Сервис представляет следующие эндпоинты: GET /tokens/{id} - позволяет получить пару токенов access + refresh для пользоввателя с заданным ID 

POST /tokens/refresh - возвращает новую пару токенов по переданному в загаловке авторизации access-токену и в теле запроса refresh-токену 

GET /tokens - возвращает ID пользователя через access-токен переданный в заголовке

DELETE /tokens/{id} - деавторизует пользователя с данным идентификатором

==============================================================================================================================================

ИНСТРУКЦИЯ ПО ЗАПУСКУ:

Выполнить команду docker compose up -d в корне проекта, сервер будет слушать на порту :8080

Swagger будет доступен по адресу: http://localhost:8080/swagger

Для проверки защищенных роутов необходимо выполнить запрос получения пары токенов по ID, скопировать выданный access-токен и в поле Authorize вписать Bearer <token>

Для проверки логики смены User-Agent необходимо выполнить запрос curl -X 'POST' \
  'http://localhost:8080/tokens/refresh' \
  -H 'User-Agent: <value>' \
  -H 'Authorization: Bearer <access>' \
  -H 'Content-Type: application/json' \
  -d ' { "old_token": "<refresh>"} '
так как браузер подменяет заголовки User-Agent

При отличии IP переданных в поле X-Forwarded-For и IP прошлого запроса будет отправлен запрос на вебхук 
 
==============================================================================================================================================

ОСОБЕННОСТИ

Формат access-токена - JWT
Алгоритм для подписи access-токена - SHA512
Access-токен передается в заголовке

Формат refresh-токена - случайная строка 32 байта в формате base64
Refresh-токен хранится в бд в виде bcrypt-хэша
После выполнения операции refresh старый access и refresh-токен будет не валиден
Токен не может быть измене на стороне клиента, так как его хэш не совпадет с исходным

Пара токенов связана между собой уникальным идентификатором (jti)

АВТОР @Strelcock